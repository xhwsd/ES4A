# 声明
```text
声明 :=
	变量声明 | 常量声明 | 函数声明 | 过程声明 | 属性声明 | 事件声明 | 事件处理声明
```

不存在隐式的声明

## 变量声明
```text
变量声明 :=
    [静态] 变量 标识符 为 类型 {, 标识符 为 类型}
```

变量可以使一个对象数据成员，或者是局部变量。它们都将被初始化为各自类型的缺省值。对象数据成员可以声明为静态，所有的该对象实例共同引用一个静态数据成员。而非静态（实例）成员都各自分配一个对象实例 

```simple
' 正确例子：变量声明

变量 data1 为 整数型 '实例数据成员
静态 变量 data2 为 整数型, data3 为 整数型 '对象数据成员

过程 Foo( )
    变量 localData 为 整数型 '局部变量
结束 过程
```

```simple
'错误例子：变量声明

过程 Foo( )
    静态 变量 localData 为 整数型 '编译时期错误：不能有“静态”局部变量
结束 过程
```

## 常量声明 
```text
常量声明 :=
	常量 标识符 为 类型 = 常量表达式 {, 标识符 为 类型 = 常量表达式}
```

常量必须是一个对象数据成员，必须在声明的时候初始化赋值。

```simple
'正确例子：常量声明

常量 ZERO 为 整数型 = 0
常量 ONE 为 整数型 = ZERO + 1, TWO 为 整数型 = ONE + 1
```

```simple
' 错误例子：常量声明
变量 Zero 为 整数型
常量 ZERO 为 整数型 = Zero '编译时期错误：需要常量值

过程 Foo ( )
    常量 LOCAL_ZERO 为 整数型 = 0 '编译时期错误：不存在局部常量
结束 过程
```

## 函数和过程声明 
```text
函数声明 :=
	[静态] 函数 标识符 ([形式参数集]) 为 类型
		声明
	结束 函数

过程声明 :=
	[静态] 过程 标识符 ([形式参数集])
		声明
	结束 过程

形式参数集 := 形式参数 {, 形式参数}
形式参数 := [传址|传值] 标识符 为 类型
```

函数和过程都是对象成员，都是可嵌套的。两者之间的不同在于：函数有一个返回值而过程没有。函数隐式声明一个局部变量来保存返回值，该局部变量命名跟函数名相同。当函数结束时，该变量的值就是函数的返回结果值。除非特别声明，参数默认是按值传递。关键字`传值`是可选的。当参数被关键字`传址`修饰时，就变成按引用传递。此时，当一个`l-value`按引用传递给参数时候，所有被调用实参的修改都将反映到`l-value`的值。如果一个`r-rvalue`按引用传递给参数，它将被当做按值传递。

```simple
' 函数和过程声明例子

过程 ParenthesizedExpressionExamples()
	变量 par1 为 整数型, par2 为 整数型, par3 为 整数型
	par1 = 1
	par2 = 2
	par3 = 3
	TestProcedure(par1, par2, par3, TestFunction())
    ' par1 还是 1，par2 还是 2，但是 par3 变成 4，第四个实际参数不是一个左值所以没有变化
结束 过程

过程 TestProcedure(par1 为 整数型, 传值 par2 为 整数型, 传址 par3 为 整数型, 传址 par4 为 整数型)
	par1 = 2
	par2 = 3
	par3 = 4
	par4 = 5
结束 过程

函数 TestFunction() 为 整数型
	TestFunction = 4 '会返回 4
结束 函数
```

## 属性声明
```text
属性声明 :=
	属性 标识符 为 类型
		[获取
			声明...
		结束 获取]
		[设置
			声明...
		结束 设置]
	结束 属性
```

属性是对象成员。一个属性声明可以定义一个`获取器`和一个`设置器`。如果没有`设置器`那么该属性是只读的，不能放在一个赋值语句的左边被引用。如果未定义`获取器`就变成只写的，只能在一个赋值语句的左边被引用`获取`函数隐式声明一个跟属性同名的局部变量。当`获取器`结束时该变量的值就是属性的值。`设置`函数同样也有一个类似的局部变量。当`设置器`开始执行时，这个变量值就被赋值成属性的值。一个属性的`获取器`和`设置器`不能再声明任何正式的参数。

```simple
' 属性声明例子 

变量 当前状态 为 文本型 '支持存储状态属性

属性 状态 为 文本型
	获取
		状态 = 当前状态 '返回 状态
	结束 获取

	设置
		当前状态 = 状态 '保存 状态
		状态标签.文本 = 状态 '更新 状态标签
	结束 设置
结束 属性

过程 部分过程()
	状态 = "Greate!" '将"Greate！"赋值给 当前状态 ，同时更新显示 状态标签 的文本
结束 过程
```

## 事件声明 
```text
事件声明 :=
	事件 标识符([形式参数集])
	结束 事件
 ```

事件属于对象成员。事件声明定义一个事件，该事件可以被`触发事件`语句触发

> 就是说可以在对象程序集中定义事件，并且可以在该对象中使用`触发事件`语句触发该事件

```simple
' 声明一个事件的例子 

事件 测试事件(文本 为 文本型)
结束 事件 
```

## 事件处理声明 
```text
事件处理声明 :=   
	事件 标识符.标识符([形式参数集])
		[声明...]
	结束 事件 
```

事件处理声明同样属于对象成员。一个对象处理器跟一个过程（procedure）类似，但是不能被直接触发。事件处理器都是由定义该事件的对象的`引发事件`语句调用。一个事件处理器定义了一个对象实例数据成员（第一个`事件`关键字前面标识符）和一个事件（第二个标识符）。实例数据成员必须在事件处理所在的对象中声明。实例数据成员必须定义相关的事件。 

> 就是说可以在对象实例化程序集中定义对象事件，然后当对象事件引发时执行相应动作（这就是事件驱动）。

```simple
' 定义事件处理器的相关例子
变量 对象1 为 事件的对象 '该变量包括了已定义一个“测试事件”的对象 

事件 对象1.测试事件(文本 为 文本型)
	状态标签 = "状态 : " & 文本
结束 事件
```

## 别名声明
```text
别名声明 :=
	别名 标识符 = 合格的标识符
```

别名声明为一个已经存在的名字重新定义了别名。后面使用这个别名就等同于使用全名。别名声明只能在变量、函数、过程、属性、事件声明前面出现。不能重定义一个别名，否则出现编译错误。 所有来自`simple.runtiom`或者它的任何子包包的对象自动使用已经定义的别名

缺省限定名的对象匹配命名空间优先级：
1. 方法局部作用域
2. 对象成员作用域
3. 单元命名空间树作用域（包括扩展类库）
4. 全局作用域（编译器定义运行类库别名 + 用户定义别名，覆盖已有）

!> 尽量避免应用包名为某类库子包名，否则会导致无法匹配到运行库中对象（可使用限定名或别名解决）！

```simple
' 正确例子 
' 你不仅可以用别名来声明较短的名称，也可以用来消除重名 

别名 FirstObjectType = com.demo.devtools.example1.ObjectType   
别名 SecondObjectType = com.demo.devtools.example2.ObjectType

变量 data1 为 FirstObjectType
变量 data2 为 SecondObjectType
```

```simple
' 错误例子 
' 重复定义别名是不允许的 

别名 Form = com.demo.devtools.example1.objectType '编译时期错误
别名 ObjectType = com.demo.devtools.example1.ObjectType 
别名 ObjectType = com.demo.devtools.example2.ObjectType '编译时期错误
```
